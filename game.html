<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Hippo Catch ‚Äî Turbo Mode</title>
  <link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --hippo-size: 70px;
      --item-size: 50px;
    }
    * { box-sizing: border-box; }
    
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'SF Pro Display', sans-serif;
      background: #000;
      color: white;
      height: 100vh;
      touch-action: none; /* Block scroll on mobile */
      user-select: none;
    }

    /* Cinematic Background */
    #bgCanvas {
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    /* UI */
    .ui-layer {
      position: absolute;
      top: 0; left: 0; right: 0;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      z-index: 10;
      pointer-events: none;
    }
    .score-box {
      background: rgba(0,0,0,0.4);
      padding: 10px 24px;
      border-radius: 20px;
      font-size: 1.5rem;
      font-weight: 800;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.15);
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .lives { font-size: 1.5rem; letter-spacing: 4px; }

    /* Game Objects */
    .game-area {
      position: absolute;
      inset: 0;
      z-index: 2;
      overflow: hidden;
    }

    .hippo {
      position: absolute;
      top: 0; left: 0; /* Base position, moved by transform */
      width: var(--hippo-size);
      height: var(--hippo-size);
      font-size: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      /* Important: GPU acceleration, no CSS transition delay */
      will-change: transform; 
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
      z-index: 10;
    }
    .hippo.hurt { filter: grayscale(1) brightness(0.5); transform-origin: center; animation: shake 0.3s; }

    @keyframes shake {
      0%, 100% { transform: translate3d(var(--x), var(--y), 0) rotate(0deg); }
      25% { transform: translate3d(var(--x), var(--y), 0) rotate(-10deg); }
      75% { transform: translate3d(var(--x), var(--y), 0) rotate(10deg); }
    }

    .item {
      position: absolute;
      top: 0; left: 0;
      font-size: 38px;
      width: var(--item-size);
      height: var(--item-size);
      display: flex;
      align-items: center;
      justify-content: center;
      will-change: transform;
      z-index: 5;
    }

    /* Menus */
    .menu-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(15px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    h1 {
      font-size: 3.5rem;
      margin: 0 0 10px;
      background: linear-gradient(to right, #fff, #4facfe);
      -webkit-background-clip: text;
      color: transparent;
      font-weight: 800;
      text-shadow: 0 10px 30px rgba(79, 172, 254, 0.3);
    }
    
    .btn {
      background: white;
      color: black;
      padding: 16px 48px;
      font-size: 1.2rem;
      border: none;
      border-radius: 50px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(255,255,255,0.4);
      transition: transform 0.1s;
    }
    .btn:active { transform: scale(0.95); }

    /* Particles */
    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      z-index: 20;
    }
  </style>
</head>
<body>

  <canvas id="bgCanvas"></canvas>

  <div class="ui-layer">
    <div class="score-box">üíé <span id="scoreVal">0</span></div>
    <div class="lives" id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  </div>

  <div class="game-area" id="gameArea">
    <div id="hippo" class="hippo">ü¶õ</div>
  </div>

  <div id="startScreen" class="menu-overlay">
    <h1>Hippo Turbo</h1>
    <p style="color:rgba(255,255,255,0.8); font-size:1.1rem; margin-bottom:30px">–õ–æ–≤–∏ —Ñ—Ä—É–∫—Ç–∏, —É–Ω–∏–∫–∞–π –Ω–µ–±–µ–∑–ø–µ–∫.<br>–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π —Å—Ç—Ä—ñ–ª–∫–∏ –∞–±–æ –¥–æ—Ç–∏–∫.</p>
    <button class="btn" onclick="startGame()">–ì–†–ê–¢–ò</button>
  </div>

  <div id="gameOverScreen" class="menu-overlay" style="display:none">
    <h1 style="font-size:3rem">–ö—ñ–Ω–µ—Ü—å –≥—Ä–∏</h1>
    <p style="font-size:1.5rem; color:white; margin-bottom:30px">–†–∞—Ö—É–Ω–æ–∫: <b id="finalScore">0</b></p>
    <button class="btn" onclick="startGame()">–©–ï –†–ê–ó</button>
  </div>

<script>
/* ------------------------------------------------
   1. HIGH PERFORMANCE RENDER ENGINE
   ------------------------------------------------ */
const bgCanvas = document.getElementById('bgCanvas');
const ctx = bgCanvas.getContext('2d');
let W, H;

function resize() {
  W = bgCanvas.width = window.innerWidth;
  H = bgCanvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Background Stars (Static array for performance)
const stars = Array.from({length: 100}, () => ({
  x: Math.random() * W, y: Math.random() * H, s: Math.random() * 2, a: Math.random()
}));

function drawBg() {
  // Clear with gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#0f172a');
  grad.addColorStop(1, '#1e293b');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Draw Stars
  ctx.fillStyle = '#fff';
  stars.forEach(st => {
    ctx.globalAlpha = 0.3 + Math.sin(performance.now() * 0.003 + st.x) * 0.2;
    ctx.beginPath();
    ctx.arc(st.x, st.y, st.s, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
  requestAnimationFrame(drawBg);
}
drawBg();

/* ------------------------------------------------
   2. GAME LOGIC (PURE MATH, NO DOM READS)
   ------------------------------------------------ */
const gameArea = document.getElementById('gameArea');
const hippoEl = document.getElementById('hippo');
const scoreEl = document.getElementById('scoreVal');
const livesEl = document.getElementById('livesDisplay');

// Config
const HIPPO_SIZE = 70;
const ITEM_SIZE = 50;
const HIPPO_SPEED = 800; // pixels per second (fast responsiveness)
const HIPPO_Y_OFFSET = 20; // pixels from bottom

// State
let isPlaying = false;
let lastTime = 0;
let score = 0;
let lives = 3;
let spawnTimer = 0;
let spawnInterval = 800; // ms

// Coordinate System
let gameW = window.innerWidth;
let gameH = window.innerHeight;
let hippoX = gameW / 2;
let hippoY = gameH - HIPPO_SIZE - HIPPO_Y_OFFSET;

// Entities
// Using a Set or Array for items. Array is fine for this scale.
let items = []; 

const ITEMS_TYPES = [
  { char: 'üçâ', type: 'good', points: 10, speed: 300 },
  { char: 'üçç', type: 'good', points: 20, speed: 350 },
  { char: 'üçá', type: 'good', points: 15, speed: 320 },
  { char: '‚ö°', type: 'bad', damage: 1, speed: 450 },
  { char: '‚ùÑÔ∏è', type: 'bad', damage: 1, speed: 350 },
  { char: 'üí£', type: 'bad', damage: 2, speed: 400 }
];

// Input State
const keys = { Left: false, Right: false };
let touchTargetX = null; // For smooth touch following

// Listeners
window.addEventListener('keydown', e => {
  if(e.key === 'ArrowLeft') keys.Left = true;
  if(e.key === 'ArrowRight') keys.Right = true;
});
window.addEventListener('keyup', e => {
  if(e.key === 'ArrowLeft') keys.Left = false;
  if(e.key === 'ArrowRight') keys.Right = false;
});

// Optimized Touch: follow finger
gameArea.addEventListener('touchstart', e => { touchTargetX = e.touches[0].clientX; });
gameArea.addEventListener('touchmove', e => { 
  e.preventDefault(); // prevent scroll
  touchTargetX = e.touches[0].clientX; 
});
gameArea.addEventListener('touchend', () => { touchTargetX = null; });

// Resize Handler for Game Logic
window.addEventListener('resize', () => {
  gameW = window.innerWidth;
  gameH = window.innerHeight;
  hippoY = gameH - HIPPO_SIZE - HIPPO_Y_OFFSET;
});

function startGame() {
  isPlaying = true;
  score = 0;
  lives = 3;
  spawnInterval = 800;
  items.forEach(i => i.el.remove());
  items = [];
  
  updateHUD();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  
  hippoX = (gameW - HIPPO_SIZE) / 2;
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function endGame() {
  isPlaying = false;
  document.getElementById('finalScore').innerText = score;
  document.getElementById('gameOverScreen').style.display = 'flex';
}

function spawnItem() {
  const type = ITEMS_TYPES[Math.floor(Math.random() * ITEMS_TYPES.length)];
  
  // DOM Creation
  const el = document.createElement('div');
  el.className = 'item';
  el.innerText = type.char;
  gameArea.appendChild(el);

  // Logic Object
  const item = {
    el: el,
    x: Math.random() * (gameW - ITEM_SIZE),
    y: -ITEM_SIZE, // start above screen
    type: type.type,
    speed: type.speed + (score * 0.5), // Difficulty scaling
    points: type.points,
    damage: type.damage
  };
  items.push(item);
}

function updateHUD() {
  scoreEl.innerText = score;
  livesEl.innerText = '‚ù§Ô∏è'.repeat(Math.max(0, lives));
}

// Visual Effects
function createFloatingText(text, x, y, color) {
  const el = document.createElement('div');
  el.innerText = text;
  el.style.position = 'absolute';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.color = color;
  el.style.fontWeight = 'bold';
  el.style.fontSize = '24px';
  el.style.pointerEvents = 'none';
  el.style.transition = 'all 0.8s ease-out';
  el.style.zIndex = 50;
  el.style.textShadow = '0 2px 4px rgba(0,0,0,0.5)';
  gameArea.appendChild(el);
  
  // Trigger animation next frame
  requestAnimationFrame(() => {
    el.style.transform = 'translateY(-50px)';
    el.style.opacity = '0';
  });
  
  setTimeout(() => el.remove(), 800);
}

/* ------------------------------------------------
   3. THE MAIN LOOP (60 FPS LOGIC)
   ------------------------------------------------ */
function gameLoop(now) {
  if(!isPlaying) return;
  
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  // 1. Move Hippo
  // Keyboard
  if (keys.Left) hippoX -= HIPPO_SPEED * dt;
  if (keys.Right) hippoX += HIPPO_SPEED * dt;
  
  // Touch (Smooth lerp towards finger)
  if (touchTargetX !== null) {
    const diff = touchTargetX - (hippoX + HIPPO_SIZE/2);
    if (Math.abs(diff) > 5) {
      hippoX += diff * 10 * dt; // Lerp factor 10
    }
  }

  // Boundaries
  if (hippoX < 0) hippoX = 0;
  if (hippoX > gameW - HIPPO_SIZE) hippoX = gameW - HIPPO_SIZE;

  // Render Hippo (GPU Transform)
  // We set CSS variable for shake animation usage, but main pos via translate
  hippoEl.style.setProperty('--x', `${hippoX}px`);
  hippoEl.style.setProperty('--y', `${hippoY}px`);
  hippoEl.style.transform = `translate3d(${hippoX}px, ${hippoY}px, 0)`;

  // 2. Spawn Items
  spawnTimer += dt * 1000;
  if (spawnTimer > spawnInterval) {
    spawnItem();
    spawnTimer = 0;
    // Increase difficulty
    spawnInterval = Math.max(300, 800 - (score * 2));
  }

  // 3. Update Items & Collisions
  // Simple AABB Collision (Axis-Aligned Bounding Box)
  // Hippo Hitbox is slightly smaller than visual for fairness
  const hitX = hippoX + 10;
  const hitY = hippoY + 20;
  const hitW = HIPPO_SIZE - 20;
  const hitH = HIPPO_SIZE - 20;

  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];
    
    // Move
    item.y += item.speed * dt;
    
    // Render Item
    item.el.style.transform = `translate3d(${item.x}px, ${item.y}px, 0)`;

    // Check Collision (Pure Math)
    // Check if rectangles overlap
    if (
      item.x < hitX + hitW &&
      item.x + ITEM_SIZE > hitX &&
      item.y < hitY + hitH &&
      item.y + ITEM_SIZE > hitY
    ) {
      // HIT!
      if (item.type === 'good') {
        score += item.points;
        createFloatingText(`+${item.points}`, item.x, item.y, '#4ade80');
      } else {
        lives -= item.damage;
        createFloatingText(`üí•`, item.x, item.y, '#ff4d4d');
        hippoEl.classList.add('hurt');
        setTimeout(() => hippoEl.classList.remove('hurt'), 300);
      }
      
      updateHUD();
      item.el.remove();
      items.splice(i, 1);

      if (lives <= 0) {
        endGame();
        return;
      }
      continue;
    }

    // Check Floor
    if (item.y > gameH) {
      item.el.remove();
      items.splice(i, 1);
    }
  }

  requestAnimationFrame(gameLoop);
}

</script>
</body>
</html>